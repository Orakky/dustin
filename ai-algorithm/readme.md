# Schedule 计划排程 需求

* 根据大组定盘计划业务逻辑抽象成数学模型
* 

# 抽象模型

* 输入参数-横坐标：横坐标代表时间,输入为一维数组，time [ "2025/10/09","2025/10/10"]
  
  ```
    ["2025/10/09","2025/10/10"] 
  ```
* 输入参数-纵坐标：总坐标代表产线，输入为二位数组，第一位代表产线名称，第二位代表产线下的面数，以0.5为一个单位 ,例如：["1",3],表示，1号产线由3个面数，但是占据6个空间，即3 / 0.5  = 6
  ```
    [["1",3],["2",4],["3",4]]
     
    // 此时针对0.5单位可进一步将纵坐标数组进行计算，优化成最终的二维数组
    
    [["1",6],["2",8],["3",8]] 
    ```
* 输入参数 - 矩阵：矩阵代表着定盘的计划，矩阵本身的代数对应业务的定盘名称，矩阵的行数量代表定盘占用了产线的面数，矩阵的列数量代表分段的定盘计划的周期天数，json仅作数据展示
  ```
    {
    "101":[5,10,"2025/10/09","2025/10/19"],
    "102":[2.5,11,"2025/10/09","2025/10/20"]
    }
    // "101"代表分段名称，即矩阵编号，
    //数组的第一个值 5 代表占据的产线面数，
    //第二个值代表是分段计划的周期天数，
    //第三个值代表分段计划的最晚开始时间，
    //第四个值代表分段计划的最早结束时间
    
    [["101",5,10,"2025/10/09","2025/10/19"],["102",2.5,11,"2025/10/09","2025/10/19"]]
    
    //index [0] 代表分段名称，即分段编号
    //index [1] 代表分段占据的产线面数，即纵坐标的长度，固定高度
    //index [2] 代表分段计划的周期天数，即横坐标的长度，固定宽度
    //index [3] 代表分段计划的最晚开始时间,限制横坐标序列的头
    //index [4] 代表分段计划的最早结束时间,限制横坐标序列的尾
    ```
* 限制条件 - 矩阵和坐标系：如果矩阵可以在坐标系中找到自己的位置，则矩阵实际存在，并且行列值均为0
* 限制条件 - 矩阵和矩阵：如果A矩阵和B矩阵在坐标系中均能找到自己的位置，并且不存在交集则A矩阵和B矩阵的行列值均为0，如果A矩阵和B矩阵在坐标系中均能找到自己的位置，但是存在交集则A矩阵和B矩阵的交集所在行列值为1，其余的行列值为0




# 数学分析

* 根据输入参数横坐标和纵坐标的宽度和高度可以构建一个二维的平面直角坐标系,即一个大型的二维数组，横坐标为时间的数量，纵坐标为产线的总面数,构建该二维数组需要构建坐标系横坐标索引跟具体时间的映射关系，构建纵坐标面数和具体产线面数的索引关系
    ```
    [[0,0,0,0,0,0],[0,0,0,0,0,0]]
    //二维数组，index[x][y] 
    // x 代表 时间索引
    // y 代表 面数索引
    ```
* 按照需求，要求分段可以在这个坐标系中都能找到自己的位置，同时满足自己的时间限制条件，而每个分段都可以用一个二维数组进行表示
    ```
    [[0,0,0],[0,0,0]]
    //二维数组，index[x][y]
    //x 代表 时间索引
    //y 代表 面数索引 
    ```
* 分段只要能在时间产线坐标系中找到自己的位置即可，所有的分段能在时间产线坐标中找到属于自己的位置，并且在坐标系中不存在交集即是对分段计划的成功排程,此时需要构建分段和坐标系的映射关系
    ```
    [[0,2],[0,2]]
    //二维数组，
    //index[0][0] - index[0][1] 代表横坐标
    //index[1][0] - index[1][1] 代表纵坐标
    
    额外构建，二维数组和分段的映射关系 
    ```
* 此时，业务已经拆解成了大坐标系下合理放置不同面积大小矩阵的的问题，并且矩阵的面积是固定。




## 算法思考

* 针对矩阵放置问题，最简单的方式是回溯算法，也就是不断尝试将当前数组矩阵按照要求放在坐标系中，紧接着尝试放置第二个矩阵，如果第二个矩阵无法放置，则需要将第一个矩阵的位置进行调整，从而不断的递归回溯。但是按照这样的思路去开发代码，也就是最简单的穷举尝试方案，组合数量爆炸，计算超量无法得到最终的结果。
* 由于矩阵的数量相对较多，同时每个矩阵的面积大小都是固定的，我们采取贪心+回溯以及剪枝。尽可能优先满足权重最大的矩阵，利用剪枝限制递归回溯的边界，减少回溯时分支的产生。
* 贪心的优先原则：优先放置权重更大也就是在坐标系中可以放置的位置最少的矩阵，好处就是这样的矩阵要是一开始就放置失败了就可以直接回溯选择新的位置，减少后续回溯的计算量
* 同时由于硬件和时间的限制，我们算法无法无穷无尽的不断递归迭代回溯，因此我们仍然需要采用启发式方法，按照约束严格程度进行排序，然后递归回溯，并且限制递归深度。我们的最终目的是在坐标系中找到最大子集，使得矩形都可以放置并且不重叠且满足约束
* 在回溯的过程中，由于纵坐标也就是我们的高度都是固定，只需要确定横坐标的位置，因此可以采取扫描线算法，在扫描线维护移动的过程中，在移动的过程中可以动态维护一个数据结构不断存储更新当前扫描线的一个状态并且计算当前矩阵的位置的数据,可以快速计算矩阵之间的交集


## 用法


* 核心类 - `CoordinateSelector` 坐标选择器类，该类接收坐标系、矩阵以及障碍点 三类数据,计算矩阵在坐标系位置的核心主类
  * 初始化 - `new CoordinateSelector(coordinateSystem)`,其中 `int[][] coordinateSystem = new int[x][y]`,目的是初始化坐标系
  * 如果要往坐标系内添加障碍物，则只需要在`coordinateSystem`对应数组赋值为1
  * `addArrayInfo(String name, int width,int height,int minStartX,int maxStartX)`,该方法用来添加矩阵信息，对应业务内的分段
    * `name - 矩阵名称,对应分段号`
    * `width -  矩阵的宽度，对应分段加工周期`
    * `height -  矩阵的高度，对应分段占据的面数`
    * `minStartX - 矩阵最小的x坐标，对应分段加工最早开始时间`
    * `maxStartX - 矩阵最大的x坐标，对应分段加工最晚开始时间`
  * `placeAllMatrix()`,该方法为核心方法，根据输入的坐标系、矩阵集合、以及障碍物数据开始计算矩阵在坐标系中的位置关系，并返回对应的结果 `MatrixResult`
  * `generateReport(matrixResult)`,该方法可以分析当前的矩阵结果,仅作参考
  * `visualDiplay()`, 控制台可视化当前的坐标系和矩阵以及障碍物情况  